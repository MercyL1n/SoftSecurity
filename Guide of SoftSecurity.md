# 软件安全考试大纲

[TOC]

## 1 软件安全概述

### 1.1 软件安全问题的原因

* 互联性

  不需要物理接触

* 扩展性

  扩展技术方便加载新的组件，但组件不可控

* 复杂性

  代码量多，系统复杂，	质量难保证



### 1.2 软件安全的概念

​	为了安全目的设计、开发、测试软件的过程，软件自身确定清楚问题





## 2 缓冲区溢出基础

### 2.1 缓冲区溢出原理

​	计算机向缓冲区内填充数据超过缓冲区本身的容量，溢出的数据覆盖在合法数据上



### 2.2 进程内存空间分区

| 名称   | 用途                                                         |
| ------ | ------------------------------------------------------------ |
| 代码区 | 存储被装入的二进制码，<br>处理器在这区域取指执行             |
| 数据区 | 存储全局变量                                                 |
| 堆区   | 动态分配和回收                                               |
| 栈区   | 动态存储函数调用的关系，<br>保证函数返回时恢复到父函数中继续执行 |



### 2.3 系统栈的工作原理—内存的不同用途



### 2.4 函数栈帧、函数调用原理

#### 函数栈帧

* 局部变量：为函数局部变量开辟空间

* 栈帧状态值：保存前栈帧的顶部和底部，用于恢复上一个栈帧

* 函数返回值：保存函数调用前的指令位置

* EIP：指向一条等待执行的指令地址

* ESP：扩展堆栈指针。这个寄存器指向堆栈的当前位置，并允许

  通过使用push和pop操作或者直接的指针操作来对堆栈中的内容

  进行添加和移除

* EBP：扩展基指针。主要用与存放在进入call以后的ESP的值，便

  于退出的时候回复ESP的值，达到堆栈平衡的目的

* EAX：一般用来做返回值

* ECX：用于记数

#### 函数调用原理

1. 参数入栈：从右向左
2. 返回地址入栈：下一跳指令地址压入栈
3. 代码区跳转：从当前代码跳转到被调用函数入口处
4. 栈帧调整
   1. 保存当前栈帧值，以备恢复使用（EBP入栈）
   2. 将当前栈帧切换到新栈帧（ESP装入EBP，更新栈帧底部）
   3. 给新栈帧分配空间（把ESP减去所需空间大小，抬高栈帧）

#### 函数返回原理

1. 保存返回值：函数返回值保存在EAX中
2. 弹出当前栈帧：给ESP加上栈帧的大小，降低栈回收当前栈帧的空间，将前栈帧EBP值弹入EBP寄存器，恢复上个栈帧，函数返回地址弹给EIP寄存器
3. 跳转：按照函数返回地址调回母函数





## 3 字符串安全

### 3.1 常见的字符串操作错误

* 无界字符串复制
  * strcpy()
  * strcat()
* 空结尾错误
  * strncpy
* 截断：目标字符数组的长度不足以容纳一个字符串内容
* 差一错误
* 数组写入越界
* 不恰当的数据处理



### 3.2 不安全字符串API

- strncpy()代替strcpy()
- fgets()代替gets()
- snprintf()代替sprintf()



### 3.3 字符串问题导致的安全漏洞

* 缓冲区溢出
  * 修改变量
  * 数据指针
  * 函数指针
  * 栈返回地址
* 程序栈
* 弧注入
  * 利用程序已存在的代码，插入一段新的弧
  * 安装已有函数，执行本地上的程序
* 代码注入
  * 构造恶意参数
  * 恶意参数必须作为合法输入
  * 运行到恶意代码前参数不能导致程序终止



### 3.4 缓解与防范措施

#### 缓解措施

* 预防缓冲区溢出
* 侦测缓冲区溢出并安全恢复

#### 防范策略

* 静态分配空间
  * 输入验证
  * strlcpy() and strlcat()：无法验证函数结果，仍可能截断
  * ISO/IEC "Security" TR 24731：不是完全安全的，最大长度不被正确指定仍会溢出
    * 包含的函数
      * strcpy_s()
      * strcat_s()
      * strncpy_s()
      * strncat_s()
    * Goals
      * 缓解
        * 缓冲区溢出攻击
        * 默认保护与计划相关文件
      * 不产生无结尾的字符串
      * 不意外截断字符串
      * 保存空字符结尾的字符串数据类型
      * 支持编译时检查
      * 使失败显现
      * 有一个统一的函数参数和返回类型模式
* 动态分配空间：不丢弃多余数据，输入被限制可能导致拒绝服务攻击想
  * SafeStr
    * 基于safestr_t类型，与char*兼容，保存内存信息（如实际长度和分配长度）
  * 错误处理
    * XXL库
  * 管理动态字符串
  * 黑名单
  * 白名单





## 4 漏洞利用技术

### 4.1 Shellcode与exploit的概念

​	shellcode：缓冲区溢出攻击中植入进程的代码

​	exploit：代码植入的过程



### 4.2 栈帧移位与jmp esp

​	栈帧移位：程序重新装入时，栈帧发生移位，使静态shellcode不能适应动态的内存

​	jmp esp：利用一条jmp esp指令的地址覆盖函数返回地址。重新布置shellcode的摆放位置后，可以准确地定位shellcode，适应栈区动态变化的要求



### 4.3 缓冲区的组成

* 填充物
* 淹没返回地址的数据
* shellcode

| 返回shellcode静态地址                        | 返回jmp esp跳板地址                        |
| -------------------------------------------- | ------------------------------------------ |
| 合理利用缓冲区，使攻击串总长度减小           | 能适应动态变化的shellcode地址              |
| 对程序破坏小，较稳定，不会大范围破坏当前栈帧 | 可能会破坏当前栈的数据，无法修复寄存器的值 |





## 5 漏洞挖掘与模糊测试

### 5.1 fuzz测试的概念与主要目标

​	概念：一种能自动进行”rough attack”尝试的工具

​	主要目标：利用“暴力”来实现对目标程序的自动化测试，然后监视检查其最后的结果，如果符合某种情况就认为程序可能存在某种漏洞或者问题。



### 5.2 文件格式fuzz测试的主要步骤

1. 正常文件为模板，按照规则产生一批畸形文件
2. 将畸形文件送入软件解析，检测是否会发生异常
3. 记录软件的错误信息，如寄存器状态和战状态
4. 用日志或者其他UI形式，向测试人员展示异常信息，鉴定错误是否能利用



### 5.3 Smart fuzz的主要特征

* 面向逻辑：解析文件的程序逻辑，而不是文件本身
* 面向数据类型：识别不同的数据类型，不同类型产生不同数据
  * 算术型
  * 指针型
  * 字符串型
  * 特殊字符
* 基于样本：构造合法的样本文件，改造一小部分进行变异





## 6 指针安全

### 6.1 基本概念

​	概念：通过修改指针值来利用程序漏洞的方法的统称



### 6.2 修改指令指针

- IC存储了将要执行的下一条指令
- IC不能被直接访问
- 在执行中递增，可以由控制转移指令间接修改
  - jmp
  - condtional jumps
  - call
  - ret 
- 静态调用对于函数地址使用立即数
  - 指令中地址被编码
  - 计算地址，然后放入IC
  - 不改变执行命令，IC不会改变
- 通过函数指针的调用是间接引用
  - IC的下一个值，存储在内存中，其可以被改变
- 控制IC使得攻击者可以选择要执行的代码
  - 攻击者能够任意写很容易
  - 间接的函数引用无法在编译期间决定的函数调用可以被利用，从而可以使程序的控制权转移到任意代码



### 6.3 内存任意写技术

​	溢出缓冲区后，覆写指针，发生内存任意写，可以改变程序控制流



### 6.4 虚函数攻击

#### 虚函数和虚表

* C++类的成员函数在声明时，若使用关键字virtual进行修饰，则被称为虚函数
* 一个类有很多虚函数
* 虚函数的入口地址存放在虚表中
* 对象使用虚函数时，先通过虚表指针找到虚表，然后在虚表中取出最终的函数入口地址进行调用
* 虚表指针保存在对象的内存空间中，紧接着虚表指针是其他成员变量
* 虚函数只有通过对象指针才能显示动态调用的特性

![虚函数实现](/image/虚函数实现.png)虚函数攻击

```c++
char[] shellcode=“………”;
class vf
{
    public:
    char buf[200];
    virtual void test(void)
    {
    	cout<<"Class Vtable::test()"<<endl;
    }
};
vf overflow, *p;

void main(void)
{
    LoadLibrary("user32.dll");
    char * p_vtable;
    p_vtable=overflow.buf-4;//point to virtual table
	__asm int 3
	//reset fake virtual table to 0x0042E430
	//the address may need to adjusted via runtime debug
    p_vtable[0]=0x30;
	p_vtable[1]=0xE4;
	p_vtable[2]=0x42;
	p_vtable[3]=0x00;
    strcpy(overflow.buf,shellcode1);//set fake
    virtual function pointer
    p=&overflow;
    p->test();
}

```



1. 虚表指针位于成员变量char buf[200]之前，程序中通过p_vtable=overflow.buf-4定位到这个指针
2. 修改虚表指针指向缓冲区的0x0042E430
3. 程序执行到p->test()时，按照伪造的虚函数指针寻找虚表，填上shellcode的起始地址，程序执行shellcode

![虚表示意图](/image/虚表示意图.png)



* 本质上是指针攻击
* 可以连续性覆盖



### 6.5 SEH攻击

#### SEH概述

​	S.E.H即异常处理结构体（Structure Exception Handler），包含两个DWORD指针，S.E.H链表指针和异常处理函数句柄



![S.E.H链表](/image/S.E.H链表.png)

1. SEH结构体存放在系统栈中
2. 线程初始化，自动向栈添加SEH
3. 源代码添加异常处理机制时，编译器向当前函数站安装SEH
4. 栈中同时存在多个SEH
5. 栈中多个SEH通过链表指针在栈内有栈顶向栈底串成单向链表，位于链表顶的SEH通过TEB（线程环境块）0字节偏移处进行标识
6. 异常发生时，操作系统会中断程序，首先从链表顶的SEH，使用异常处理函数句柄指向的代码
7. 执行失败顺序尝试执行其他SEH函数
8. 都不能处理，强制关闭

#### SEH攻击

```c++
#include <windows.h>
char shellcode[]=“\x90\x90…”;// 由 于 我 们 要 得 到
//shellcode起始位置，S.E.H地址等信息，所以我们
//先用0x90来进行填充
DWORD MyExceptionhandler(void)
{
    printf(“got an exception,press Enter to killprocess!\n”);
    getchar();
    ExitProcess(1);
}//这是我们自己编写的异常处理函数

void test(char* input)
{
    char buf[200];
    int zero=0;
    __asm int 3 //int 3指令可以中断进程开始调试
    __try
    {
    strcpy(buf,input);//产生栈溢出
    zero=4/zero;//除0产生异常
    }
    __except(MyExceptionhandler()){}
}

int main(){
    test(shellcode);
    return 0;
}
```

1. 函数test中存在典型的栈溢出漏洞。
2. __try{}会在test的函数栈帧中安装一个S.E.H结构。
3. __try中的除0操作会产生一个异常
4. 当strcpy操作没有产生溢出时，除0操作的异常将最终被MyExceptionHandler函数处理
5. 当strcpy操作产生溢出，并精确地将栈帧中的S.E.H异常处理句柄修改为shellcode的入口地址时，操作系统将会错误地使用shellcode去处理除0异常，代码植入成功。
6. 此外，异常处理机制会检测进程是否处于调试状态。如果直接用调试器加载程序，异常处理会进入调试状态下的处理流程。因此我们在代码中加入断点__asm int 3，让进程中断，然后用调试器attach的方法进行调试

#### SafeSEH和SEHOP

SafeSEH：

 * 校验异常处理链是否在当前程序栈中
* 检查异常处理函数是否指向当前的函数栈
* RtlIsValidHandler()，有效性验证

SEHOP：

​	检查链的完整性，转入异常处理前检查SEH链上最后一个函数是否为系统固定的终极异常处理函数



### 6.6 Windows内存安全机制

#### GS编译

​	在函数返回地址前首先检测Security Cookie是否被覆盖，从而把针对操作系统的栈溢出变得非常困难。

#### DEP

​	将数据部分标识为不可执行，阻止了栈、堆和数据节中攻击代码的执行

#### Heap cookie

​	Cookie被布置在堆首部分原堆块的segment table 的位置，占一个字节

#### Safe Unlink

​	卸载free list堆块加入验证

#### ASLR

​	系统关键地址随机化：映像随机化，堆栈随机化，PEB和TEB





## 7 格式化输出

### 7.1 格式化输出函数原理

​	由一个格式字符串和可变数目的参数构成，将参数压栈



### 7.2 典型的格式化输出函数和格式化符

#### 格式化输出函数

* fprintf()按照格式字符串的内容
* printf()
* sprintf()
* snprintf()

#### 格式化字符串

* 格式字符串是由普通字符（包括%）和转换规范构成的字符序列
* 普通字符被原封不动地复制到输出流中
* 转换规范根据与实参对应的转换指示符对其进行转换，然后将结果写入输出流中
* 转换规范通常以%开始按照从左向右的顺序解释
* 当参数过多时，多余的将被忽略
* 而当参数不足时，则结果是未定义的
* 一个转换规范组成
  * 可选域：标志、宽度、精度以及长度修饰符
  * 必需域：转换指示符，按照下面的格式



### 7.3 格式化输出函数可能导致的安全问题

* 缓冲区溢出
* 使程序崩溃
* 查看栈内容
* 查看内存内容
* 覆写内存



### 7.4 可扩展的缓冲区

```c++
char outbuf[512];
char buffer[512];
sprintf(
	buffer,
    "ERR Wrong command: %.400s",
    user
);
sprintf(outbuf, buffer);	//%497d\x3c\xd3\xff\xbf<nops><shellcode>
//使用strcpy和strncpy消除漏洞
```



* 格式规范%497d指示函数sprintf()从栈中读出一个假的参数并向缓冲区中写入497个字符。

* 包括格式字符串中的普通字符在内，现在写入的字符总数已经超过了outbuf的长度4个字节。

* 用户输入可被操纵用于覆写返回地址，也就是拿恶意格式字符串参数中提供的利用代码的地址(0xbfffd33c）去覆盖该地址。

* 在当前函数退出时，控制权将以与栈粉碎攻击相同的方式转移给利用代码



### 7.5 使程序崩溃

* 格式字符串漏洞通常是在程序崩溃的时候才被发现。

* 在UNIX系统中，存取无效的指针会引起进程收到SIGSEGV信号。

* 除非能够捕捉并处理，否则程序将会非正常终止并导致核心转储（dump core ）。

* 与之类似，在Windows中读取一个未映射的地址将会导致系统的一般保护错误并导致程序非正常终止。



### 7.6 覆写内存

* %n是用来帮助排列格式化输出字符串的，它将字符数目成功地输出到以参数的形式提供的整数地址中

例：

```c++
printf("\xdc\xf5\x42\x01%08x.%08x.%08x%n”);
//将28（8*3+4）写入0x0142f5dc中
```

* 可以使用具有具体宽度或精度的转换规范控制

例：

```c++
int i;
printf ("%10u%n", 1, &i); /* i = 10 */
printf ("%100u%n", 1, &i); /* i = 100 */
```

![覆写内存](/image/覆写内存.png)

* 覆写内存的步骤
  1. 每一次地址递增的时候，都会在低内存中保留一个字节的尾值
  2. 这个字节在小尾端架构中是低位字节，而在大尾端架构中则为高位字节
  3. 这个过程可用于通过一系列小整数的值（＜255）来实现写一个大整数值（一个地址）的目的
  4. 这个过程还可以颠倒过来，即还可以在地址递减时从高位内存写到低位内存





## 8 整数安全



### 8.1 整数表示方法：原码、反码、补码

​	略



### 8.2 带符号和无符号整数

​	有符号：-2^n-1^ 到 2 ^n-1^-1

​	无符号：-2^n^-1



### 8.3 整数取值范围

* 该类型的表示法

* 是否带符号

* 分配的内存位数大小



### 8.4 整数转换、整形提升、隐式转换

#### 整型提升

```c++
char c1,c2;
c1 = c1 + c2;
//c1和c2都被提升到int类型大小，然后就和结果截断适应char类型
```

* 自变量表达式
* 一元的+、-、~
* 移位操作



### 8.5 整数转换规则

* 没有任何两种不同的带符号整型具有相同的级别，即使它们的（内存）表示法相同
* 低精度的带符号整型的级别比高精度的带符号整型类型的级别低
* long long int类型的级别比long int 高，long int的级别比int高， int的级别比short int高， short int的级别比signed char高、
* 无符号整型的级别与对应的带符号整型的级别相同
* 从较小的无符号整型转换到较大的无符号整型
  *  总是安全的
  * 通常通过对其值进行零扩展而完成
* 当一个较大的无符号整型被转换到一个较小的无符号整型的时候
  * 较大的值将会被戳断
  * 低位数据被保留
* 当无符号整型转换到其对应的带符号整型的时候
  * 位模式（即所有的位数据）将会被保留，因此没有数据会因此丢失
  * 最高位数据变成了符号位
* 当一个非负的带符号整数被转换为一个相同大小或更大的无符号整型的时候
  *  值不会发生变化
  *  带符号整数需作符号扩展
* 当一个带符号整数被转换为一个较短的带符号整数的时候
  * 通过截断高位完成的
* 当带符号整数转换到无符号整数
  * 其位模式被保留，故不会有数据的丢失
  *  高位失去了符号位的功能
  * 如果带符号整型的值非负的话，那它的值不会发生改变
  * 如果其值是负数的话，得到的无符号结果将被求值为一个非常大的无符号整数



### 8.6 整数溢出类别及原理

#### 整数溢出

​	当一个整数被增加超过其最大值或被减小小于其最小值时即会发生整数溢出

#### 截断错误

* 将一个较大整型的数转换到较小的整型
* 该数的原值超出较小类型的表示范围

#### 符号错误

* 从无符号整型转换到带符号整型
  * 相同大小-位模式保留不变; 最高位变成符号位
  * 更大- 进行符号扩展，然后才执行转换
  * 更小-保留低位
  * 如果无符号整数的最高位
  * 没被设置- 值不变
  * 被设置 – 变成负值
* 带符号整型转换到无符号整型
  * 相同大小-位模式保留不变; 最高位变成符号位
  * 更大- 进行符号扩展，然后才执行转换
  * 更小-保留低位
* 带符号整数的值
  * 非负的- 值不变
  * 负的 -结果通常是一个很大的正值





## 9 动态内存安全

### 9.1 动态内存管理函数

* C标准定义的内存分配函数

  * calloc

  ```c++
  calloc(size_t nmemb, size_t size);
  //为数组分配内存，该数组共有nmemb个元素，每个元素的大小为size个字节，并返回一个指向所分配的内存的指针
  //所分配的内存的内容全部被设置为0
  ```

  * malloc

  ```c++
  malloc(size_t size);
  //分配size个字节，并返回一个指向分配的内存的指针
  //分配的内存未被初始化为一个已知值
  ```

  * realloc

  ```c++
  realloc(void *p, size_t size);
  //将p所指向的内存块的大小改为size个字节
  //新大小和旧大小中较小的值那部分内存所包含的内容不变
  //新分配的内存未做初始化
  //如果p是空指针，则该调用等价于malloc(size)
  //如果size等于0，则该调用等价于free(p)
  //如果p不是空指针，则其必须是早先调用malloc(),calloc(), 或者realloc()所返回的结果
  ```

* free

```c++
free(void * p);
// 释放由p指向的内存空间，这个p必须是先前通过调用malloc(), calloc(), 或者 realloc()返回的
//如果free(p) 此前已经被调用过，将会导致未定义行为
//如果p是空指针，则不执行任何操作
```

* new
* delete



### 9.2 内存分配算法

* 连续匹配方法
* 最先匹配
* 最佳匹配
* 伙伴系统
* 隔离



### 9.3 常见的内存错误

#### 初始化错误

*  程序员假设malloc()把分配的内存的所有位初始化为零
* 初始化大的内存块可能会降低性能并且不总是必要的

#### 未检查返回值

* 内存是有限的资源，它可能会被耗尽
* 内存分配函数报告调用者状态
  * VirtualAlloc() 返回NULL
  * Microsoft Foundation Class Library (MFC) new表达式抛出CMemoryException *
  * HeapAlloc() 可能返回NULL或者产生结构化异常
* 应用程序应该
  * 决定什么时候错误发生
  * 以合适方式处理异常
* 如果不能分配请求的空间，那么malloc()函数返回一个空指针
* 在不能分配内存时，有个一致的恢复计划是需要的
*  PhkMalloc
  *  PhkMalloc提供了－个X选项，在启用主选项的情况下，当分配失败时，内存分配器会向标准错误输出设备打印一段诊断信息并调用abort()，而不是返回错误状态值
  * C++中的new表达式抛出bad_alloc异常

#### 引用已释放内存

* 不可能导致运行时错误
* 已释放的内存在读操作之前可被分配
  * 读操作读取的数值不正确
  * 写操作损坏其他变量
* 已释放内存能被内存管理器使用
  * 写操作能损坏内存管理器元数据
  * 很难诊断运行时错误
  * 漏洞利用的基础

#### 对同一块内存释放多次

​	作为错误处理的结果，内存块被释放，但在正常处理过程中再次被释放

#### 不正确配对的内存管理函数

* 总是使用
  * new-delete
  * malloc-free

#### 未能区分标量和数组

* C++对于标量和数组
  * new-delete 标量
  * new[]-deletep[] 数组

#### 分配函数使用不当

* malloc(0)
  * 能导致内存管理错误
  * C运行时库能返回
    *  空指针
    * 伪地址
* alloca()
  * 功能
    * 在调用者的栈中分配内存
    * 在调用alloca()的函数返回时自动释放该内存
  * 定义
    *  没有在POSIX, SUSv3, C99中定义
    *  但某些BSD, GCC, Linux发行版本均支持
  * 问题
    * 通常实现为内联函数
    * 分配空间时超出栈边界
    * 程序员经常感到困惑并释放通过alloca()函数返回内存



### 9.4 Dlmalloc空闲块管理

#### 空闲块

* 以双链表形式组织
* 包含下一块的前向指针和指向上一块的后向指针
* 最后4字节存有该块大小
* 已分配块和空闲块用PREV_INUSE区分，块大小总是偶数，PREV_INUSE位被存储于块大小的低位中

![空闲块](/image/空闲块.png)

​										空闲块的结构

![](/image/空闲块的组织.png)

​										空闲块的组织

* free时
  * 和相邻空闲块合并
    * 被释放块的上一块为空闲块
      * 与被释放的块合并
    *  被释放块的下一块为空闲块
      * 也从双链表中解开
      * 并与被释放块合并



### 9.5 解链技术

unlink宏

```c++
#define unlink(P, BK, FD) {\
        FD = P->fd; \
        BK = P->bk; \
        FD->bk = BK; \
        BK->fd = FD; \
}
```

![解链技术](/image/解链技术.png)

​											解链技术

* unlink()宏将攻击者提供的4个字节的数据写到同样是由攻击者指定的4个字节的地址处
  * 一旦攻击者可以在任意地址处写入4字节数据，利用该漏洞程序本身的权限执行任意代码就变得简单多了
  * 攻击者可能会提供栈中指令指针的地址，然后利用unlink()宏将该地址覆写为恶意代码的地址
  * 将漏洞程序调用的函数的地址替换为恶意代码的地址
  * 攻击者可以检查程序的可执行映像，找到free()函数的调用跳槽（jump slot ）地址
    * address-12处的值包含在恶意参数中，因此unlink()宏会将free()库函数调用地址覆写为shellcode的地址
    *  每当程序调用free()时都会转而执行shellcode



### 9.6 RTL堆基本概念

* RTL – Run Time Library
* 使用虚拟内存API
* 实现了更高级的局部、全局和CRT内存函数
